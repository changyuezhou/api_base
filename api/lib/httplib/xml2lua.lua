--- Overview:
--  =========
--
--      This module provides a non-validating XML stream parser in Lua. 
--  
--  Features:
--  =========
--  
--      * Tokenises well-formed XML (relatively robustly)
--      * Flexible handler based event API (see below)
--      * Parses all XML Infoset elements - ie.
--          - Tags
--          - Text
--          - Comments
--          - CDATA
--          - XML Decl
--          - Processing Instructions
--          - DOCTYPE declarations
--      * Provides limited well-formedness checking 
--        (checks for basic syntax & balanced tags only)
--      * Flexible whitespace handling (selectable)
--      * Entity Handling (selectable)
--  
--  Limitations:
--  ============
--  
--      * Non-validating
--      * No charset handling 
--      * No namespace support 
--      * Shallow well-formedness checking only (fails
--        to detect most semantic errors)
--  
--  API:
--  ====
--
--  The parser provides a partially object-oriented API with 
--  functionality split into tokeniser and handler components.
--  
--  The handler instance is passed to the tokeniser and receives
--  callbacks for each XML element processed (if a suitable handler
--  function is defined). The API is conceptually similar to the 
--  SAX API but implemented differently.
--  
--  The following events are generated by the tokeniser
--  
--      handler:start       - Start Tag
--      handler:end         - End Tag
--      handler:text        - Text
--      handler:decl        - XML Declaration
--      handler:pi          - Processing Instruction
--      handler:comment     - Comment
--      handler:dtd         - DOCTYPE definition
--      handler:cdata       - CDATA 
--  
--  The function prototype for all the callback functions is
--      
--      callback(val, attrs, start, end)
--  
--  where attrs is a table and val/attrs are overloaded for 
--  specific callbacks - ie.
--  
--      Callback     val            attrs (table)
--      --------     ---            -------------
--      start        name           { attributes (name=val).. }
--      end          name           nil
--      text         <text>         nil
--      cdata        <text>         nil
--      decl         "xml"          { attributes (name=val).. }
--      pi           pi name        { attributes (if present)..
--                                    _text = <PI Text>
--                                  }
--      comment      <text>         nil     
--      dtd          root element   { _root = <Root Element>,
--                                    _type = SYSTEM|PUBLIC,
--                                    _name = <name>,
--                                    _uri = <uri>,
--                                    _internal = <internal dtd>
--                                  }
--
--  (start & end provide the character positions of the start/end
--  of the element)
--
--  XML data is passed to the parser instance through the 'parse'
--  method (Note: must be passed a single string currently)
--
--  License:
--  ========
--
--      This code is freely distributable under the terms of the [MIT license](LICENSE).
--
--
--@author Paul Chakravarti (paulc@passtheaardvark.com)
--@author Manoel Campos da Silva Filho

local _G, print, string, table, pairs, type, tostring, tonumber, error, io, setmetatable, getmetatable
      = 
      _G, print, string, table, pairs, type, tostring, tonumber, error, io, setmetatable, getmetatable

module "xml2lua"

---Converts the decimal code of a character to its corresponding char
--if it's a graphical char, otherwise, returns the HTML ISO code
--for that decimal value in the format &#code
--@param code the decimal value to convert to its respective character
local function decimalToHtmlChar(code) 
    local n = tonumber(code)
    if n >= 0 and n < 256 then
        return string.char(n) 
    else
        return "&#"..code..";"
    end
end

---Converts the hexadecimal code of a character to its corresponding char
--if it's a graphical char, otherwise, returns the HTML ISO code
--for that hexadecimal value in the format &#xCode
--@param code the hexadecimal value to convert to its respective character
local function hexadecimalToHtmlChar(code) 
    local n = tonumber(code, 16)
    if n >= 0 and n < 256 then
        return string.char(n) 
    else
        return "&#x"..code..";"
    end
end


---Recursivelly prints a table in an easy-to-ready format
--@param tb The table to be printed
--@param level the indentation level to start with
local function printableInternal(tb, level)
  level = level or 1
  local spaces = string.rep(' ', level*2)
  for k,v in pairs(tb) do
      if type(v) == "table" then
         print(spaces .. k)
         printableInternal(v, level+1)
      else
         print(spaces .. k..'='..v)
      end
  end  
end

---Recursivelly prints a table in an easy-to-ready format
--@param tb The table to be printed
function printable(tb)
    printableInternal(tb)
end

---Handler to generate a string prepresentation of a table
--Convenience function for printHandler (Does not support recursive tables).
--@param t Table to be parsed
--@return a string representation of the table
function showTable(t)
    local sep = ''
    local res = ''
    if type(t) ~= 'table' then
        return t
    end

    for k,v in pairs(t) do
        if type(v) == 'table' then 
            v = showTable(v)
        end
        res = res .. sep .. string.format("%s=%s", k, v)    
        sep = ','
    end
    res = '{'..res..'}'

    return res
end


---Class to parse XML
XmlParser = {
    --  Available options are -
    --  
    --      * stripWS   
    --      
    --        Strip non-significant whitespace (leading/trailing) 
    --        and do not generate events for empty text elements
    --  
    --      * expandEntities 
    --  
    --        Expand entities (standard entities + single char 
    --        numeric entities only currently - could be extended 
    --        at runtime if suitable DTD parser added elements
    --        to table (see obj._ENTITIES). May also be possible
    --        to expand multibyre entities for UTF-8 only
    --  
    --      * errorHandler
    --  
    --        Custom error handler function 
    --
    --  NOTE: Boolean options must be set to 'nil' not '0'
    options = {},
    
    -- Private attribures/functions
    _stack      = {},
    _handler    = {},

    _XML        = '^([^<]*)<(%/?)([^>]-)(%/?)>',
    _ATTR1      = '([%w-:_]+)%s*=%s*"(.-)"',
    _ATTR2      = '([%w-:_]+)%s*=%s*\'(.-)\'',
    _CDATA      = '<%!%[CDATA%[(.-)%]%]>',
    _PI         = '<%?(.-)%?>',
    _COMMENT    = '<!%-%-(.-)%-%->',
    _TAG        = '^(.-)%s.*',
    _LEADINGWS  = '^%s+',
    _TRAILINGWS = '%s+$',
    _WS         = '^%s*$',
    _DTD1       = '<!DOCTYPE%s+(.-)%s+(SYSTEM)%s+["\'](.-)["\']%s*(%b[])%s*>',
    _DTD2       = '<!DOCTYPE%s+(.-)%s+(PUBLIC)%s+["\'](.-)["\']%s+["\'](.-)["\']%s*(%b[])%s*>',
    _DTD3       = '<!DOCTYPE%s+(.-)%s*(%b[])%s*>',
    _DTD4       = '<!DOCTYPE%s+(.-)%s+(SYSTEM)%s+["\'](.-)["\']%s*>',
    _DTD5       = '<!DOCTYPE%s+(.-)%s+(PUBLIC)%s+["\'](.-)["\']%s+["\'](.-)["\']%s*>',

    _ATTRERR1   = '=%s*"[^"]*$',
    _ATTRERR2   = '=%s*\'[^\']*$',
    _TAGEXT     = '(%/?)>',

    _errstr = { 
        xmlErr = "Error Parsing XML",
        declErr = "Error Parsing XMLDecl",
        declStartErr = "XMLDecl not at start of document",
        declAttrErr = "Invalid XMLDecl attributes",
        piErr = "Error Parsing Processing Instruction",
        commentErr = "Error Parsing Comment",
        cdataErr = "Error Parsing CDATA",
        dtdErr = "Error Parsing DTD",
        endTagErr = "End Tag Attributes Invalid",
        unmatchedTagErr = "Unbalanced Tag",
        incompleteXmlErr = "Incomplete XML Document",
    },

    _ENTITIES = { 
        ["&lt;"] = "<",
        ["&gt;"] = ">",
        ["&amp;"] = "&",
        ["&quot;"] = '"',
        ["&apos;"] = "'",
        ["&#(%d+);"] = decimalToHtmlChar,
        ["&#x(%x+);"] = hexadecimalToHtmlChar
    }    
}

---Instantiates a XmlParser object to parse a XML string
--@param handler Handler module to be used to convert the XML string
--to another formats. See the available handlers at the handler directory.
-- Usually you get an instance to a handler module using, for instance:
-- local handler = require("xml2lua/handler/tree").
--@return a XmlParser object used to parse the XML
--@see XmlParser
function parser(handler)     
    if handler == _G["xml2lua"] then
        error("You must call xml2lua.parse(handler) instead of xml2lua:parse(handler)")
    end

    local obj = {
        _handler    = handler,

        -- Public attributes
        options = { 
            --Indicates if whitespaces should be striped or not
            stripWS = 1, 
            expandEntities = 1,
            errorHandler = function(errMsg, pos) 
                error(string.format("%s [char=%d]\n", errMsg or "Parse Error", pos))
            end
        }
    }

	setmetatable(obj, XmlParser)
	XmlParser.__index = XmlParser

    return obj
end

--Main function which starts the XML parsing process
--@param str the XML string to parse
--@param parseAttributes indicates if tag attributes should be parsed or not. If omitted, the default value is true.
function XmlParser:parse(str, parseAttributes)
    if type(self) ~= "table" or getmetatable(self) ~= XmlParser then
        error("You must call xmlparser:parse(parametrs) instead of xmlparser.parse(parametrs)")
    end
    
    if parseAttributes == nil then
        parseAttributes = true
    end
    self._handler.parseAttributes = parseAttributes

    local match, endmatch, pos = 0, 0, 1
    local text, endt1, endt2, tagstr, tagname, attrs, starttext, endtext
    local errstart, errend, extstart, extend
    while match do
        -- Get next tag (first pass - fix exceptions below)
        match, endmatch, text, endt1, tagstr, endt2 = string.find(str, self._XML, pos) 
        if not match then 
            if string.find(str, self._WS, pos) then
                -- No more text - check document complete
                if #self._stack ~= 0 then
                    self:_err(self._errstr.incompleteXmlErr,pos)
                else
                    break 
                end
            else
                -- Unparsable text
                self:_err(self._errstr.xmlErr,pos)
            end
        end 

        -- Handle leading text
        starttext = match
        endtext = match + string.len(text) - 1
        match = match + string.len(text)
        text = self:_parseEntities(self:_stripWS(text))
        if text ~= "" and self._handler.text then
            self._handler:text(text,nil,match,endtext)
        end
        
        -- Test for tag type
        if string.find(string.sub(tagstr,1,5),"?xml%s") then
            -- XML Declaration
            match,endmatch,text = string.find(str, self._PI, pos)
            if not match then 
                self:_err(self._errstr.declErr,pos)
            end 
            if match ~= 1 then
                -- Must be at start of doc if present
                self:_err(self._errstr.declStartErr,pos)
            end
            tagname,attrs = self:_parseTag(text) 
            -- TODO: Check attributes are valid
            -- Check for version (mandatory)
            if attrs.version == nil then
                self:_err(self._errstr.declAttrErr,pos)
            end
            if self._handler.decl then 
                self._handler:decl(tagname,attrs,match,endmatch) 
            end
        elseif string.sub(tagstr,1,1) == "?" then
            -- Processing Instruction
            match,endmatch,text = string.find(str,self._PI,pos)
            if not match then 
                self:_err(self._errstr.piErr,pos)
            end 
            if self._handler.pi then 
                -- Parse PI attributes & text
                tagname,attrs = self:_parseTag(text) 
                local pi = string.sub(text,string.len(tagname)+1)
                if pi ~= "" then
                    if attrs then
                        attrs._text = pi
                    else
                        attrs = { _text = pi }
                    end
                end
                self._handler:pi(tagname,attrs,match,endmatch) 
            end
        elseif string.sub(tagstr,1,3) == "!--" then
            -- Parse a Comment
            match,endmatch,text = string.find(str,self._COMMENT,pos)
            if not match then 
                self:_err(self._errstr.commentErr,pos)
            end 
            if self._handler.comment then 
                text = self:_parseEntities(self:_stripWS(text))
                self._handler:comment(text,next,match,endmatch)
            end
        elseif string.sub(tagstr,1,8) == "!DOCTYPE" then
            -- Parse DTD
            match,endmatch,attrs = self:_parseDTD(string,pos)
            if not match then 
                self:_err(self._errstr.dtdErr,pos)
            end 
            if self._handler.dtd then
                self._handler:dtd(attrs._root,attrs,match,endmatch)
            end
        elseif string.sub(tagstr,1,8) == "![CDATA[" then
            -- Parse CDATA
            match,endmatch,text = string.find(str,self._CDATA,pos)
            if not match then 
                self:_err(self._errstr.cdataErr,pos)
            end 
            if self._handler.cdata then
                self._handler:cdata(text,nil,match,endmatch)
            end
        else
            -- Parse a Normal tag
            -- Need check for embedded '>' in attribute value and extend
            -- match recursively if necessary eg. <tag attr="123>456"> 
            while 1 do
                errstart,errend = string.find(tagstr,self._ATTRERR1)
                if errend == nil then
                    errstart,errend = string.find(tagstr,self._ATTRERR2)
                    if errend == nil then
                        break
                    end
                end
                extstart,extend,endt2 = string.find(str,self._TAGEXT,endmatch+1)
                tagstr = tagstr .. string.sub(str,endmatch,extend-1)
                if not match then 
                    self:_err(self._errstr.xmlErr,pos)
                end 
                endmatch = extend
            end 

            -- Extract tagname/attrs
            tagname,attrs = self:_parseTag(tagstr) 

            if (endt1=="/") then
                -- End tag
                if self._handler.endtag then
                    if attrs then
                        -- Shouldnt have any attributes in endtag
                        self:_err(string.format("%s (/%s)",
                                            self._errstr.endTagErr,
                                            tagname)
                                    ,pos)
                    end
                    if table.remove(self._stack) ~= tagname then
                        self:_err(string.format("%s (/%s)",
                                            self._errstr.unmatchedTagErr,
                                            tagname)
                                    ,pos)
                    end
                    self._handler:endtag(tagname,nil,match,endmatch)
                end
            else
                -- Start Tag
                table.insert(self._stack,tagname)
                if self._handler.starttag then
                    self._handler:starttag(tagname,attrs,match,endmatch)
                end
                --TODO: Tags com fechamento automático estão sendo
                --retornadas como uma tabela, o que complica
                --para a app NCLua tratar isso. É preciso
                --fazer com que seja retornado um campo string vazio.
                -- Self-Closing Tag
                if (endt2=="/") then
                    table.remove(self._stack)
                    if self._handler.endtag then
                        self._handler:endtag(tagname,nil,match,endmatch)
                    end
                end
            end
        end
        pos = endmatch + 1
    end
end


-- Private functions ----------------------------------------

function XmlParser:_err(err, pos)
    if self.options.errorHandler then
        self.options.errorHandler(err,pos)
    end
end

--Removes whitespaces
function XmlParser:_stripWS(s)
    if self.options.stripWS then
        s = string.gsub(s,'^%s+','')
        s = string.gsub(s,'%s+$','')
    end
    return s
end

function XmlParser:_parseEntities(s) 
    if self.options.expandEntities then
        --for k,v in self._ENTITIES do
        for k,v in pairs(self._ENTITIES) do
            --print (k, v) 
            s = string.gsub(s,k,v)
        end
    end

    return s
end
        
function XmlParser:_parseDTD(s, pos)
    -- match,endmatch,root,type,name,uri,internal
    local m,e,r,t,n,u,i
    m,e,r,t,u,i = string.find(s,self._DTD1,pos)
    if m then
        return m,e,{_root=r,_type=t,_uri=u,_internal=i} 
    end
    m,e,r,t,n,u,i = string.find(s,self._DTD2,pos)
    if m then
        return m,e,{_root=r,_type=t,_name=n,_uri=u,_internal=i} 
    end
    m,e,r,i = string.find(s,self._DTD3,pos)
    if m then
        return m,e,{_root=r,_internal=i} 
    end
    m,e,r,t,u = string.find(s,self._DTD4,pos)
    if m then
        return m,e,{_root=r,_type=t,_uri=u} 
    end
    m,e,r,t,n,u = string.find(s,self._DTD5,pos)
    if m then
        return m,e,{_root=r,_type=t,_name=n,_uri=u} 
    end

    return nil
end

---Parses a string representing a tag
--@param s String containing tag text
--@return Returns a string containing the tagname and a table attrs
--containing the atributtes of tag
function XmlParser:_parseTag(s)
    local attrs = {}            
    local tagname = string.gsub(s,self._TAG,'%1')
    local parseFunction = function (k,v) 
            attrs[string.lower(k)]=self:_parseEntities(v)
            attrs._ = 1 
          end
                          
    string.gsub(s, self._ATTR1, parseFunction) 
    string.gsub(s, self._ATTR2, parseFunction)

    if attrs._ then
        attrs._ = nil
    else 
        attrs = nil
    end

    return tagname, attrs
end

function loadFile(xmlFilePath)
    local f, e = io.open(xmlFilePath, "r")
    if f then
        --Gets the entire file content and stores into a string
        return f:read("*a")
    end
    
    error(e)
end
